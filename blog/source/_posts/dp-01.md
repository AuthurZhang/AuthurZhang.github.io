---
title: dp_01
date: 2019-07-05 13:25:17
tags:
- dp
- knapsack
categories:
- dp
top:90
---

# Dynamic Programming 01 - Knapsack

## Abstract

Introduce some basic dp question - 0/1 knapsack and complete knapsack

<!--more-->

## 0/1 Knapsack

### Question

There are *n* things, and you have a  knapsack which can contains *m* weight things, each thing has its value *v*, the question is how to get the max value within given weight?

### Analysis

We need to draw the table, and we can get the max value in the end of the table.

Thus, the core of code is simulation of this operation.

### Code

- original code

```Java
    /**
     * question 1 : find max
     * @param weight
     * @param val
     * @param maxWeight
     */
    public static int knapsack_01(int[] weight, int[] val, int maxWeight){

        //init dp array i = num+1 j = weight+1
        int num = weight.length;
        int[][] dp = new int[num][maxWeight+1];

        //operation
        for(int i = 1; i < num; i++){
            for(int j = 1; j < maxWeight+1; j++){

                if( j < weight[i] ){

                    dp[i][j] = dp[i-1][j];
                }else {

                    dp[i][j] = Math.max(dp[i-1][j-weight[i]]+val[i],dp[i-1][j]);
                }
            }
        }

        return dp[num-1][maxWeight];
    }
```

- change the 2D dp to 1D dp

```Java
    /**
     * 一维解 01背包
     * @param weight
     * @param val
     * @param maxWeight
     */
    public static int knapsack_05(int[] weight, int[] val, int maxWeight){

        int[] dp = new int[maxWeight+1];
        int num = weight.length;

        for(int i = 0; i < num; i++){

            for(int j = maxWeight; j >= weight[i]; j--){

                dp[j] = Math.max(dp[j],dp[j-weight[i]]+val[i]);
            }
        }

        return dp[maxWeight];
    }
```

- how to find the list of things when get the max?

Use Retrospective method - 回溯法

```java
    /**
     * question 2: find max and then get solution
     * 回溯法
     * @param weight
     * @param val
     * @param maxWeight
     * @return
     */
    public static void knapsack_02(int[] weight, int[] val, int maxWeight){

        //init dp array i = num+1 j = weight+1
        int num = weight.length;
        int[][] dp = new int[num][maxWeight+1];

        //operation
        for(int i = 1; i < num; i++){
            for(int j = 1; j < maxWeight+1; j++){

                if( j < weight[i] ){

                    dp[i][j] = dp[i-1][j];
                }else {

                    dp[i][j] = Math.max(dp[i-1][j-weight[i]]+val[i],dp[i-1][j]);
                }
            }
        }

        //find best Retrospective method
        Boolean[] select = new Boolean[num];
        int tempJ = maxWeight;
        for(int i = num-1; i >= 1; i--){
            if(dp[i][tempJ] == dp[i-1][tempJ]){
                select[i] = false;
            }else if(tempJ>=weight[i] && dp[i][tempJ] == dp[i-1][tempJ-weight[i]]+val[i])             {
                select[i] = true;
                tempJ -= weight[i];
            }
        }

        System.out.println(Arrays.toString(select));
    }
```

## Complete knapsack

### Question

Question is almost the same , but we can use one things for n times instead of one time.

### Analysis

The same method, the different point is that in every unit of table, we need to compare for many times.

### Code

- 2D code

```java
    /**
     * 无限背包（完全背包）
     * @param weight
     * @param val
     * @param maxWeight
     */
    public static int knapsack_03(int[] weight, int[] val, int maxWeight){

        //init dp array i = num+1 j = weight+1
        int num = weight.length;
        int[][] dp = new int[num][maxWeight+1];

        //operation
        for(int i = 1; i < num; i++){
            for(int j = 1; j < maxWeight+1; j++){

                for(int k = 0; k*weight[i] <= j; k++){

                    dp[i][j] = Math.max(dp[i-1][j-k*weight[i]]+k*val[i],dp[i][j]);

                }

            }
        }

        return dp[num-1][maxWeight];
    }
```

- 1D code

```java
    /**
     * 一维解 完全背包
     * @param weight
     * @param val
     * @param maxWeight
     */
    public static int knapsack_06(int[] weight, int[] val, int maxWeight){
        int[] dp = new int[maxWeight+1];
        int num = weight.length;

        for(int i = 0; i < num; i++){

            for(int j = 0; j <= weight[i]; j++){

                dp[j] = Math.max(dp[j],dp[j-weight[i]]+val[i]);
            }
        }
        return dp[maxWeight];
    }
```

### Comparison of 1D code, 0/1 Knapsack is from maxWeight to w[i], and complete Knapsack is from w[i] to maxWeight.



